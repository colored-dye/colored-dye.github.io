---
title: LeetCode-002-DP-01
date: 2021-09-15 22:22:04
tags: [Algorithm, LeetCode]
categories: [Algorithm, LeetCode]
mathjax: true
---

今天来记录几道动态规划的题目\~这几道题都是同一主题：买卖股票(Best Time to Buy and Sell Stock)。这一系列题目在最初版本的基础上加了一些限定条件，使得问题的解决略有复杂，但是基本的思路是一致的。

<!--more-->

#### Easy Version

最简单版本就是给出一系列非负数`prices[]`作为股价，但是有以下限定条件：

1.   任意一天最多只能拥有一股。
2.   某一天买下后，最早只能第二天卖。

要求给出赚得最多的金额。

将第$i$天的盈利记为$f(i)$，那么我们可以给出这样的转移方程：
$$
f(i) = f(i-1) + max(prices[i]-prices[i-1], 0) 
$$
其实就是将所有的上升子序列的首末值加在一起就好了。

#### Normal Version: With Cooldown

所谓的“Cooldown”就是指，某一天卖掉股票后，第二天就不能买了，最早第三天才能买。

加了这个限定条件后，转移方程就不能像前一个那样简单了。我们需要明确，在股票交易的全程中，一共可能出现三种状态：

1.   `f[i][0]`: 刚刚卖掉，正处于冷冻期。
2.   `f[i][1]`: 正持有股票。
3.   `f[i][2]`: 不持有股票，并且不处于冷冻期。

对应于以上三种状态，我们可以得到如下的状态转移方程：

1.   $f[i][0] = f[i-1][0] + prices[i]$ : 当天刚刚卖掉股票，所以收益等于前一天的收益加上卖掉股票的收益。
2.   $f[i][1] = max(f[i-1][1], f[i-1][2]-prices[i])$ : 当前的股票有可能在第`i-1`天就已经持有，也有可能是当天买入的。如果是前者，就相当于在`f[i-1][2]`收益的基础上支出了。
3.   $f[i][2] = max(f[i-1][0], f[i-1][2])$ : 既没有股票也不处于冷冻期，说明当天没有买股票，并且第`i-1`天也没有股票。

那么我们很容易想到，最终的收益是$max(f[n-1][0], f[n-1][1], f[n-1][2])$. 但是在最后一天持有股票是没有价值的，所以只需要计算$max(f[n-1][0], f[n-1][2])$即可。

接下来还需要确定的就是这三个收益函数的初值。假如第0天买入，就相当于得到了负数的收益，那么`f[0][0] = 0`, `f[0][1] = -prices[0]`, `f[0][2] = 0`.

接下来就可以照葫芦画瓢写代码啦：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }

        int n = prices.size();
        // f[i][0]: 手上不持有股票，并且处于冷冻期中的累计最大收益
        // f[i][1]: 手上持有股票的最大收益
        // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益
        vector<vector<int>> f(n, vector<int>(3));
        f[0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            f[i][0] = f[i - 1][0] + prices[i];
            f[i][1] = max(f[i - 1][1], f[i - 1][2] - prices[i]);
            f[i][2] = max(f[i - 1][0], f[i - 1][2]);
        }
        return max(f[n - 1][0], f[n - 1][2]);
    }
};
```

#### Another Version: With Transaction Fee

同样，我们需要分析几种可能出现的状态：

1.   `f[i][0]` : 当天手里没有股票。
2.   `f[i][1]` : 当天手里有股票。

对应这两种状态，我们可以写出两个状态转移方程：

1.   $f[i][0] = max(f[i-1][0], f[i-1][1] + prices[i] - fee)$ : 当天手里没有股票，可能是昨天已经卖掉，也可能是当天卖掉。对于后一种可能，除了获得相应的收益之外，还要支付交易费。交易费其实是针对一对买卖行为的，但是由于只能持有一股，所以只需要在卖掉时付费。
2.   $f[i][1] = max(f[i-1][1], f[i-1][0] - prices[i])$ : 当天手里有股票，可能是前一天已经买入，也有可能是当天买入。

所以可以得出，最后的最大收益为$max(f[n-1][0], f[n-1][1])$. 同样，最后一天持有股票没什么意义，所以结果就是$f[n-1][0]$.

此外，还需要确定初值。如果第一天先买股票，那么`f[i][0] = 0`, `f[i][1] = -prices[0]`.

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][0] = 0, dp[0][1] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
};
```



----

#### 小小总结

经过后两道题我们可以感受到，只要写出了状态转移方程，写出相应的代码就会很容易。所以在正确理解题意的基础上，需要我们认真仔细地给出递归形式的状态转移方程，而这些方程往往都遵循着动态规划类型题目的基本模式。（多刷一些题应该可以总结得差不多吧( •̀ ω •́ )✧
